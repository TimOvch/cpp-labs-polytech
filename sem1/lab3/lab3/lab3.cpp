/*************************************************************
    Практическое занятие №3. Встроенные массивы.
                            Динамическое выделение памяти.
                            Простейшие алгоритмы сортировки и поиска.
                            Сложные указатели.
                            Ссылки.
*************************************************************/
#include <iostream>
#include <ctime>
#include <string>

using namespace std;

#define    stop

void swap(char* a, char* b){
    char* tmp = a;
    a = b;
    b = tmp;
}

void swap(int& a, int& b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{

///////////////////////////////////////////////////////////////
//            Встроенные массивы                               //
///////////////////////////////////////////////////////////////
/*
    //Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
    //значения элементов следующим образом:
    //а) проинициализируйте массив при объявлении
    //б)* объявите неинициализированный массив и присвойте значения элементам
    //    с помощью кода
    //                     |--------|
    //                   / |3  3  3 |
    //                 |---------|3 |
    //               / | 2  2  2 |3 |
    //              |---------|2 |__|
    //              | 1  1  1 |2 | /
    //              | 1  1  1 |__|
    //              | 1  1  1 | /
    //              |_________|
    //Средствами отладчика проверьте правильность Вашего решения.

*/
const int n=3,m=3,k=3;

int threeMerMas[3][3][3] = {{{1,1,1},{1,1,1},{1,1,1}},{{2,2,2},{2,2,2},{2,2,2}},{{3,3,3},{3,3,3},{3,3,3}}};
int threeMerMas2[n][m][k];

for(int i = 0; i < 3; i++){
    for(int j = 0; j<3; j++){
        for(int u = 0; u<3; u++){
            threeMerMas2[i][j][u] = i+1;
        }
    }
}


    //в) найдите сумму элементов массива
     
int summ = 0;

for(int i = 0; i < 3; i++){
    for(int j = 0; j<3; j++){
        for(int u = 0; u<3; u++){
            summ+=threeMerMas2[i][j][u];
        }
    }
}
    //г) проинициализируйте массив при определении:
    //                     |--------|
    //                   / |3  0  0 |
    //                 |---------|0 |
    //               / | 2  0  0 |0 |
    //              |---------|0 |__|
    //              | 1  0  0 |0 | /
    //              | 0  0  0 |__|
    //              | 0  0  0 | /
    //              |_________|

int threeMerMas3[3][3][3] = {{{1}},{{2},{},{}},{{3},{},{}}};


    //д)* Инициализация массивов строковыми литералами:
    //Объявите и проинициализируйте строковыми литералами два массива:
    //двухмерный массив и массив указателей. Поясните разницу в использовании
    //элементов таких массивов.

char strLit[2][6] = {"Hello", "World"};

char* strLitp[2]={"Hello","World"};

// Разница между использованием элементов таких массивов заключается в типе данных, который хранится в каждом элементе
// и способе доступа к этим элементам. В массиве strLit каждый элемент представляет собой массив символов. В этом случае
// мы можем обратиться к каждому конкретному символу.
// В массиве strLitp же элемента всего 2, оба указывают на первый символ отдельных строк.

///////////////////////////////////////////////////////////////
//            Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
    //Задание2. Создайте динамический двухмерный массив с размерностями,
    //вычисляемыми в процессе выполнения программы - N*M.
    //Задайте значения элементов помощью генератора случайных чисел.
    //Найдите  сумму элементов.
    //Подсказка 1: для генерации случайных чисел используйте функцию
    //стандартной библиотеки - rand() (<cstdlib>)
    //Подсказка 2: На самом деле те значения, которые создаются генератором случайных
    //чисел являются «псевдослучайными», то есть при двух последовательных запусках
    //приложения Вы получаете две одинаковые последовательности значений.
    //Для того чтобы генерируемые "случайные" значения были разными при каждом
    //запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
    //и time() (<ctime>).
    //Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
    //Функция time() задает эту точку отсчета, считывая текущее время
    
    srand(time(0));

    int n2 = 10;
    int m2 = 10;

    //cin >> m >> n;

    // Создание массива

    int** arr = new int*[n2];

    for(int i = 0; i < n2; i++)
    {
        arr[i] = new int[m2];
    }

    //Заполнение и нахождение суммы

    long long sum = 0;

    for(int i = 0; i < n2; i++)
    {
        for(int j = 0; j < m2; j++)
        {
            arr[i][j] = rand();
            sum+=arr[i][j];
        }
    }

    //Задание2а. В сформированном массиве отсортируйте каждую строку по
    //убыванию значений. Используйте сортировку "выбором"

    for(int i = 0; i < n2; i++)
    {
        for(int j = 0; j < m2-1; j++)
        {
            int jmax = j;
            for(int k = j+1; k < m2; k++)
            {
                if(arr[i][k] > arr[i][jmax]) jmax = k;
            }
            swap(arr[i][j], arr[i][jmax]);
        }
    }

    //Задание2б. Объявите одномерный массив размерностью N.
    //Сформируйте значение i-ого элемента одномерного массива
    //равным среднему значению элементов i-ой строки
    //двухмерного массива

    int* srZn = new int[n2];

    for(int i = 0; i < n2; i++)
    {
        int srMZn = 0;
        for(int j = 0; j < m2; j++)
        {
            srMZn+= arr[i][j];
        }
        srMZn = srMZn/m2;
        srZn[i] = srMZn;
    }

    delete[] srZn;
    //Подсказка - не забудьте освободить память!

    // Удаление массива

    for(int i = 0; i < n2; i++)
    {
        delete[] arr[i];
    }

    delete[] arr;

    /////////////////////////////////////////////////////////////////////
    //Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
    //потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
    //упорядочивая полученное значение по возрастанию
    
    int NN = 10;

    // cin >> NN;

    int* odArr = new int[NN];
    
    for(int i = 0; i < NN; i++)
    {
        int nz;
        //cin >> nz;
        nz = rand()%100;
        if(i==0) {
            odArr[0]=nz;
            continue;
        }
        if(nz > odArr[i-1])
        {
            odArr[i] = nz;
        }
        else
        {
            int ctr = 0;
            while(odArr[ctr]<nz){
                ctr++;
            }
            for(int j = NN-1;j > ctr ; j--)
            {
                swap(odArr[j],odArr[j-1]);
            }
            odArr[ctr] = nz;
        }
    }

    //б) Простой поиск.
    //Модифицируйте предыдущее задание следующим образом:очередное значение
    //вводится в массив только при условии, что там еще такого нет (то есть
    //дубли игнорируются

    for(int i = 0; i < NN; i++)
    {
        int nz;
        //cin >> nz;
        nz = rand()%100;
        if(i==0) odArr[0]=nz;
        else
        {
            bool flag = true;
            for(int k = 0; k < i;k++){
                if (odArr[k]==nz){
                    flag = false;
                }
            }
            if(flag){
                if(nz > odArr[i-1])
                {
                    odArr[i] = nz;
                }
                else
                {
                    int ctr = 0;
                    while(odArr[ctr]<nz) {
                        ctr++;
                    }
                    for(int j = NN-1;j > ctr ; j--)
                    {
                        swap(odArr[j],odArr[j-1]);
                    }
                    odArr[ctr] = nz;
                }
            }
        }
    }

     delete[] odArr;

    ///////////////////////////////////////////////////////////////////////////
    //Задание 4*.С помощью данной заготовки напишите программу,
    //которая:
    //вводит строки с клавиатуры с помощью cin>>...
    //в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
    //признаком конца ввода является символ * (то есть строка - "*") или
    //заполнение массива (больше свободных строк нет);
    //сортировка строк в алфавитном порядке. Пояснение: крайне
    //не рекомендуется для сортировки сложных объектов физически
    //перемещать их в памяти. Намного эффективнее завести массив
    //указателей на соответствующие строки и перемещать только
    //указатели.

    //Подсказка: для лексиграфического сравнения строк пользуйтесь
    //функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.

    
    //Определите необходимые значения как константы
     #define STOP_STRING "*"    //признак "прекратить ввод"
     #define M 80    //максимальный размер одной строки
     #define N 5    //максимальное количество строк в массиве
    // #define startL 65 // начало заглавных в ascii
    // #define endL 90 // конец заглавных
    // #define startl 97 // начало строчных в ascii
    // #define endl 122 // конец строчных
    


    //Объявите двухмерный массив с именем cBuffer типа char и
    // размерностью N*M

    char cBuffer[N][M];


    //Объявите массив (с именем cPointers) указателей на строки
    //размерностью N

    char* cPointers[N];

    //Цикл ввода строк:
    //а) выведите приглашение для ввода

    int nIndex = 0;

    //б) пока не введена строка STOP_STRING или не заполнен весь массив
    while(nIndex < N)
    {
        cout << "Enter your string: ";
        //ввод строки в массив cBuffer:
        //cin.getline(cBuffer[nIndex], M);
        
        //если введена строка - признак окончания, то выйти из цикла
        if(strcmp(cBuffer[nIndex], STOP_STRING)==0){
            break;
        }
        //Присвойте элементу массива cPointers с индексом nIndex
        //указатель на строку с номером nIndex в массиве cBuffer
        cPointers[nIndex] = cBuffer[nIndex];
        nIndex++;
    }


    //Выдать диагностику о том, что прием строк завершен.

    cout << "All strings accepted";

    //Теперь сортируем строки:

    //Цикл сортировки строк по методу "всплывающего пузырька" в
    //порядке возрастания. На каждой итерации - промежуточная печать
    //отсортированных строк

    for (int i = 0; i < N-1; i++){
        for (int j = 0; j < N-i-1; j++){
            if (strcmp(cPointers[j],cPointers[j+1]) >= 0){
                    char* temp = cPointers[j];
                    cPointers[j] = cPointers[j+1];
                    cPointers[j+1] = temp;
        }
    }
}


cout << '\n';
    //Задание 5*. Реализуйте задание №4, используя не встроенные,
    //а динамические массивы (массив?). Так как строки могут быть разной длины,
    //эффективным решением было бы отводить под каждую строку ровно столько байтов,
    //сколько требуется для ее хранения.
    //При этом необходимые параметры (количество строк
    // сформируйте с помощью потока ввода
    int nStringNumber;

    cout << "Enter strings quantity:";

    cin >> nStringNumber;
    cin.ignore();
  
    //Цикл ввода строк:

    char** strings = new char*[nStringNumber];

    for (int i = 0; i < nStringNumber; ++i) {
        string input;
        cout << "Enter string: ";
        //getline(cin, input);

        int stringSize = input.size();
        strings[i] = new char[stringSize + 1]; // +1 для символа '\0' в конце строки

        // Копирование строки в выделенnную память
        strcpy(strings[i], input.c_str()); // string::c_str возвращает указатель на область памяти, где хранит саму строку.
    //То есть, при возвращении не создает никаких дополнительных массивов, ничто никуда не преобразовывает и не копирует
    }

    //Цикл сортировки строк по методу "всплывающего пузырька" в
    //порядке возрастания кода первого символа

    for (int i = 0; i < nStringNumber-1; i++){
        for (int j = 0; j < nStringNumber-i-1; j++){
            if (strcmp(strings[j],strings[j+1]) >= 0){
                    char* temp = strings[j];
                    strings[j] = strings[j+1];
                    strings[j+1] = temp;
            }
        }
    }
    
    
      
        
    //Освобождение занятой памяти:
     for (int i = 0; i < nStringNumber; ++i) {
        delete[] strings[i];
     }

    delete[] strings;

    //Задание 6*. Объявление и использование указателей на многомерные
    // массивы. Проинициализируйте трехмерный массив
    //double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
    //кода, который меняет местами значения элементов четных
    //и нечетных слоев:
    //    было:                 |--------|
    //                     / |4  4  4 |
    //                     |--------|    4 |
    //                   / |3  3  3 |    4 |
    //                 |---------|3 |   |
    //               / | 2  2  2 |3 | /
    //              |---------|2 |__|
    //              | 1  1  1 |2 | /
    //              | 1  1  1 |__|
    //              | 1  1  1 | /
    //              |_________|

    //    стало:                 |--------|
    //                     / |3  3  3 |
    //                     |--------|    3 |
    //                   / |4  4  4 |    3 |
    //                 |---------|4 |   |
    //               / | 1  1  1 |4 | /
    //              |---------|1 |__|
    //              | 2  2  2 |1 | /
    //              | 2  2  2 |__|
    //              | 2  2  2 | /
    //              |_________|

    double dArray[4][3][3];

    for(int i = 0; i < 4; i++){
        for(int j = 0; j < 3; j++){
            dArray[i][j][0] = i+1;
            dArray[i][j][1] = i+1;
            dArray[i][j][2] = i+1;
        }
    }

    for(int i=0; i<4; i+=2)
    {
    //Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
        auto &even_layer = dArray[i];
        auto &odd_layer = dArray[i+1];
        //переставляем местами элементы i-того и i+1-ого слоев
        swap(even_layer, odd_layer);
    }

    ///////////////////////////////////////////////////////////////////////////
    //Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
    //Сформируйте значения элементов массива с помощью генератора случайных
    //чисел таким образом, чтобы в массиве были только символы '*' и '_'

    #define NzN  5 // кол-во строк
    #define MzN 10 // кол-во элементов в строках
    #define NumZvAscii 52 // Номер звездочки в ascii
    #define NumNPAscii 137 // Номер нмжнего подчеркивания в ascii
    
    char zN[5][10];
    for(int i = 0; i < NzN; i++){
        for(int j = 0; j < MzN; j++){
            if(rand()%2){
                zN[i][j] = '*';
            }
            else{
                zN[i][j] = '_';
            }
        }
    }

    //В каждой строке "сдвиньте звездочки" в начало строки, например:
    //было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
    //стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
    //и распечатайте массив по строкам - "постройте распределение"

    for(int k = 0; k < NzN; k++){
        for (int i = 0; i < MzN-1; i++){
            for (int j = 0; j < MzN-i-1; j++){
                if (zN[k][j] > zN[k][j+1]){
                        char temp = zN[k][j];
                        zN[k][j] = zN[k][j+1];
                        zN[k][j+1] = temp;
                }
            }
        }
    }

    for (int i = 0; i < NzN; i++){
        for (int j = 0; j < MzN; j++){
            cout << zN[i][j];
        }
        cout << '\n';
    }
    // 7б. Модифицируйте предыдущее задание следующим способом:
    //После заполнения массива с помощью генератора случайных чисел
    //"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
    //"распределение"

    char zN2[NzN][MzN];
    for(int i = 0; i < NzN; i++){
        for(int j = 0; j < MzN; j++){
            if(rand()%2){
                zN2[i][j] = '*';
            }
            else{
                zN2[i][j] = '_';
            }
        }
    }

    for(int i = 0; i < MzN; i++){
        for (int j = 0; j < NzN-1; j++){
            for (int k = 0; k < NzN-j-1; k++){
                if (zN2[k][i] < zN2[k+1][i]){
                    char temp = zN2[k][i];
                    zN2[k][i] = zN2[k+1][i];
                    zN2[k+1][i] = temp;
                }
            }
        }
    }

    for (int i = 0; i < NzN; i++){
        for (int j = 0; j < MzN; j++){
            cout << zN2[i][j];
        }
        cout << '\n';
    }

    return 0;
}
