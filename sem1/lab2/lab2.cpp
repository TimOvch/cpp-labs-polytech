/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/

#include <iostream>
#include <cmath>

using namespace std;

#define	  stop	//с помощью директивы препроцессора задаем
							//макроподстановку

int post_inc(int * x)
{
	int val = *x;
	*x += 1;
	return val;
}

inline int max(int a, int b)
{
	return a > b ? a : b;
}

int main()
{
// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{
	int y = 9;//Задайте значение y, например, с помощью потока ввода
	//cin >> y;
	//С помощью побитовых операторов и операторов сдвига выведите значение "y"
	//на консоль в двоичном виде, например:
	//если y==9, то
	// а) 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)

	//или пропустите незначащие нули - б) 1 0 0 1
	constexpr int size = sizeof(y)*8; // нашли кол-во двоичных разрядов
	bool first1 = false; // переменная станет true при входе первой единицы
	for(int i = size-1; i>=0;i--){
        int bit = (y >> i) & 1;
		if(bit == 1){
			first1 = true;
		}
		if(first1){
			cout << bit << ' ';
		}
    }

	}
	

	//1.2 Дана целая переменная
	{
		int y = 9;//Задайте значение y, например, с помощью потока ввода
		//cin >> y;
		//"Сдвиньте" все единицы в этой переменной вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Реализовать задачу посредством одного цикла!
		int size = sizeof(y)*8; // нашли кол-во двоичных разрядов
		int c1=0; // в этой переменной будет лежать номер разряда двоичного числа, которое станет 1
		int answer = 0; // переменная, в которой будем хранить ответ

		for(int i = size-1;i >= 0; i--){
			int bit = (y >> i) & 1;
			if(bit == 1){
				answer|= (1 << c1);
				c1++;
			}
		}


	}


	//1.3* Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
	short sNum = 0x8008; // 1000000000001000
	short sRes;
	

	//0x7ff7 32759 0111111111110111
	sRes = ~sNum;
	//sRes = sNum /* тут побитовая операция и операнд, чтобы получить число 0x7ff7 */;

	//0x8ff8 1000111111111000 
	sRes = sNum | 0b0000111111110000;

	//0x0008 1000
	sRes = sNum&0b1000;

	//0x7f08 0111111100001000
	sRes = sNum^0b1111111100000000;

	//0xf001 1111000000000001
	sRes = sNum>>3;

	//0x0010 10000
	sRes = sNum<<1;
	
	stop
	}

	
// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???C помощью #define объявить нужные константы перед импортом библиотеки

	int radius = 2;

	int lenCir = 2*radius*M_PI;
	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
		#define LENGHT(r) ((r)*2*M_PI);
		float l1 = LENGHT(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGHT(2); // должно быть 0.07957...
		stop
	}




	



	//2.2.2* определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно

	#define MAX(a,b) (((a) > (b)) ? a : b)

	int i = 10, j = 12, k;
	k = MAX(i, j); // резульат 12, как и ожидалось
	k = MAX(j, i) * 2; // резульат 24, как и ожидалось
	k = MAX(j, i+3); // резульат 13, чтобы замена работала корректно я поставил скобки при объявлении макроса вокруг a и b
	k = MAX(i--, j++); // резульат 13, поскольку 

	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа??? Скорее всего произойдет неявное приведения типа к инту, возможна ошибка компиляции
	//или же непредсказуемое поведение программы
	
	#define EXCHANGE(a,b) ({auto x = b; b = a; a = x;})

	int x1=1, y1=-1;
	EXCHANGE(x1,y1);

	int x2=100, y2=-100;
	EXCHANGE(x2,y2);


	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?
	// Для значения 0, нужно чтобы были объявленны #define NNN и #define MMM
	// Для значения 1 нужно только #define MMM false
	// Для значения 2 нужно только #define NNN

int iNN;
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;

#else
	iNN = -1;
#endif
	
	stop

	


	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros
	
	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration


	#ifdef _DEBUG
  		cout << __FILE__ << " " << __LINE__ << " " << __DATE__ << " " << __TIME__ << " " << __FUNCTION__ ;
	#else
    	cout << "Release configuration!";
	#endif


	//Задание 2.5.* Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, определите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.

	#ifdef _UNICODE
	wchar_t str = 'A';
	#else
	char str = 'A';
	#endif

// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

	#ifdef _DEBUG
	#include "1.h"
	#else
	#include "2.h"
	#endif


// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"

	int a = 10;
	int* uka = &a; 

	// указателям присвоены адреса переменных в памяти

	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?

	const char* ukb = "abc";

	ukb = "dfg"; // присвоить значение можно

	stop



	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3};
		int* pn = &nAr[0]; // указатель на нулевой элемент массива
		(*pn)++; // прибавили к нулевому элементу массива единицу
		pn++; // передвинули указатель на первый элемент массива

		char cAr[]={'A','B','C','D'};
		char* pc = &cAr[0]; // указатель на нулевой элемент массива
		(*pc)=(*pc)+5; // прибавили к нулевому элементу массива 5 и получили 70, т. е. 'F'
		pc=pc+3; // сдвинули указатель на третий элемент массива
	
		double dAr[3]={1.0,2.0};
		double* pd1 = &dAr[0]; // указатель на нулевой элемент массива
		double* pd2 = pd1; // второй указатель на нулевой элемент массива
		(*pd2)+=2; // прибавили к нулевому элементу массива 2
		pd2+=2; // сдвинули второй указатель на второй элемент массива

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1; // указатели на элементы массива работают таким образом, что при прибавлении числа n к указателю
		// указатель сдвигается на n элементов вперед, соответсвенно в данном случае pd2 указывает на элемент с индексом 1, а
		// указатель pd1 на элемент с индексом 0, и при вычитании мы получаем 1-0=1
		int hhhh=1;
		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		double d1;
		//double *pd1 = &d1;
		pd1++;

		stop
	}

	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

    unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)
	unsigned char* pucObject5;
	//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	char cc = *(pucObject5++); // Значение, на которое указывает pucObject5 (136, из-за переполнения -120), копируется 
	// в переменную cc, а затем указатель pucObject5 перемещается на следующий бит памяти
	cc = (*pucObject5)++; // cc = 119, после этого *pucObject = 120

	cc = ++*(pucObject5); // Значение, на которое указывает pucObject5 (120), сначала увеличивается на единицу => 121, 
	// а затем  копируется в переменную cc = 121.
	cc = *(++pucObject5); // Сначала указатель перемещается на следующий бит памяти и *pucObject5 = 102
	// после чего cc = 102
	stop


	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;
	pVoid=&nObject3;
	pVoid=&cObject3;
	pVoid=pInt;
	
	// В трех крайних строчках void-указателю присваиваются адреса в памяти переменных различных типов, void-указатель
	// не обладает информацией о типе переменных

	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=static_cast<int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		void* voidP = (void*)&n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) такое приведение может привести к неопределенному поведению программы
	// в таком случае лучше сначала привести указатель типа pVoid к указателю типа double и после этого привести
	// указатель типа double к указателю типа int

	// QUAKE FAST INVERTED SQUARE 1 / sqrt(x)


	stop

		//Задание 8*. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель

		//Задание 8a. Указатель является константой. 

	int CoInt = 123;
	int* const pCoInt = &CoInt;

	const int newCoInt = *pCoInt; // получил значение

	int* newuk = &CoInt;

	*newuk = 124; // изменил значение
	
	stop	 


	//Задание 8б. Указываемое значение является константой.

	const int Const = 10;
	const int* pOnConst = &Const;

	int noConstNew = *pOnConst; // получил значение

	int NewNewNew = 11;
	int* pNewNewNew = &NewNewNew;
	pOnConst = pNewNewNew; // поменял значение адресом
	
	// в этом случае можно поменять адрес указателя, но нельзя поменять значение константы
	
	stop


		//Задание 8в. И указатель, и указываемое значение
		//являются константами. 

	const int CoInt2 = 123;
	const int* const pCoInt2 = &CoInt2;

	const int newCoInt2 = *pCoInt2; // получил значение

	// изменить значение константы невозможно, поменять адрес указателя тоже

	stop


		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;
	const int* pnN = &nN;

	// идентично с пунктом 8б
	
	//Объявите указатель и проинициализируйте его выражением - &nN	

	stop


	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1

	int* pn = &n1;

    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn

	int** ppn = &pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn

	int*** pppn = &ppn;
  
	//С помощью указателей pn, ppn и pppn получите значение объекта n1
	//и присвойте его n2

	int n2=*pn;
	n2 = **ppn;
	n2 = ***pppn;
	
	// по сути строчки идентичны, в каждом указателе содержится один и тот же адрес

  
	stop




	return 0;
}//end main
