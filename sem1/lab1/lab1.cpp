/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность 
	закомментированных блоков, которые требуется последовательно раскомментировать, 
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего 
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к. 
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что 
			исполняемый код будет содержать информацию для отладчика - 
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или 
		просто кликните левой кнопкой на левой серой полосе окна редактирования; 
	5. запустите программу в режиме отладки 
		(Debug/Start... или  F5);

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие 
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с 
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода

int nTwin=1;			//глобальная переменная
namespace TwinSpace{ int nTwin=2;}	//переменная объявлена в
						//пространстве имен - TwinSpace

#define	  stop	//с помощью макроподстановки задаем "пустую" команду.
				//Эта макроподстановка нужна только для того, чтобы
				//можно было поставить на этой строке точку останова.

int main()
{

 //**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байт, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.

	setlocale(LC_CTYPE, "rus");
	char cByte = 'A'; // объявили переменную cByte и инициализировали ее значением 'A' либо же 65
	cByte = cByte + 3; // теперь в переменной лежит значение 'D' поскольку тип char можно представить в числовом варианте и это будет номер символа в таблице ASCII, поэтому можно совершать математические операции для смены номера символа
	cByte = 0x42; // в переменной теперь лежит значение 'B', которое имеет номер 66, поскольку 0x42 это 66 в шестнадцатиричной системе счисление
	cByte = 42; // в cByte положили значение 42 т.е. символ '*'
	cByte = 66; // в cByte положили значение 66 т.е. символ 'B'
	cByte = 0; // положили в переменную 0, теперь ее значение NULL т.е. ничего либо ноль
	cByte = -0; // -0 не отличается от 0, поэтому значение сохранилось
	cByte = -1;	// значения типа char лежат в диапазоне от -128 до 127, поэтому теперь в переменной лежит символ  или '\xff';
	cByte = 127; // теперь в переменной лежит символ , номер которого 127
	cByte = cByte + 1; // т.к. мы выходим за диапазон типа char случается переполнение и значение становится -128 или символ Ђ
	cByte = 128; // тут мы сделали по сути тоже самое, что и в предыдущей строке. переменная данного типа переполнилась и поэтому значение стало -128 или символ Ђ
	cByte = cByte + 1; // тут все логично, было значение -128, прибавили 1 и стало -127 или символ Ѓ
	cByte = cByte -1; // -127-1=-128 или символ Ђ
	cByte = cByte - 1; // снова переполнение, но теперь мы перешли из нижнего значения в вверхнее 127 и символ 
	cByte = -128; // значение -128 и символ Ђ
	cByte = 127; // теперь в переменной лежит символ , номер которого 127
	cByte = -127; // значение -127 или символ Ѓ

	unsigned char ucByte = 0x41; // объявили переменную ucByte типа unsigned char и инициализировали значением 0x41, который в дес. системе счисления равняется 65 и символ 'A'
	ucByte   = 'B'; // значение 66 и символ 'B'
	ucByte   =	-1; // т.к. в типе unsigned char значения лежат в диапазоне от 0 до 255, мы сталкиваемся с переполнением и значением 255, а символ 
	ucByte = ucByte + 1; // из-за переполнения при прибавлении к 255 мы получили 0 и значение NULL
	ucByte = 255; // значением 255 и символ 
	ucByte = 255 + 1; // снова из-за переполнения при прибавлении к 255 мы получили 0 и значение NULL

	int iInt; // объявили, но не инициализировали переменную iInt
	iInt =  0xffffffff; // в переменной лежит -1, поскольку тип int содержить значение от 2 147 483 648 до 2 147 483 647. Тут мы кладем в переменную значение 4 294 967 295, только в шестнадцатиричной системе, и происходит переполнение как раз до -1
	iInt += 1; // было -1, теперь 0
	iInt = 16; // присвоили значение 16
	iInt = 0xABCDEF98; // данное число это 2 882 400 152 в шестнадцатиричной, оно выходит за пределы инта и переполнением получается значение -1 412 567 144

	unsigned int uiInt = 0xffffffff; // объявили переменную uiInt типа unsigned int, который соджержит в себе значения от 0 до 4 294 967 295. После этого инициализировали ее значением 4 294 967 295 в шестнадцатиричной системе счисления

	float fFloat = 1.f; // объявили переменную типа float и инициализировали ее 1
	double dDouble = 1.; // объявили переменную типа double и инициализировали ее 1. С типом float double отличается точностью, у дабла она выше

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789; // в переменную заносится 0.12345678901234568, число отличается кол-вом заков после запятой от инициализатора потому что точность дабла от 15 до 17 значащих цифр после запятой
	d = 2.7; // в переменной записано значение 2.7000000000000002, поскольку тип имеет ограниченую точность у нас появляются округление дальнейших чисел после запятой, это и приводит к появлению двойки
	float  f = 0.1234567890123456789123456789; // в переменной записано значение 0.123456791, поскольку точнось флоата от 6 до 9 цифр после запятой
	f = 2.7; // значение 2.70000005 и ситуация схожа с переменной d, но тип флоат имеет меньшую точность и поэтому неточность больше

	d	=	1.; // значение 1
	d	=	0.999999999999999999999999999999999; // переменная осталась равна 1, в результате вышеупомянутой неточности значение округлилось до 1

	stop
	
	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'A';
	cw = 'Ф';
	size_t n = sizeof(cw); // размер 4

	stop


// **************************************************************
	//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt=1;
	double dDouble1=iInt/3;		    // (1) мы поделили инт на инт и только потом привели к даблу, поэтому сначала 1/3 = 0, и потом присваивание значения и неявное приведение
	double dDouble2=iInt/3.;	    // (2) тут же мы неявно привели единицу к вещественному типу и поделили на вещественную 3, после чего округлили до точности дабла
	double dDouble3=(float)iInt/ 3;	// (3) в этой ситуации мы привели единицу к типу флоат, что и вызвало появление большей неточности, поделели на 3 и округления и после этого неявно привели даблу


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble=fFloat=iInt=sShort=cByte=3.3/3;			// (1) Изначально в переменную целочисленного типа char кладется значение 3.3/3=1, после этого значение 1 переходит в переменную sShort типа short, после этого iInt приравнивается к 1, после переменная fFloat инициализируется 1 и переменная dDouble

	cByte=sShort=iInt=fFloat=dDouble=3.3/3;			// (2) Изначально уже переменная dDouble типа double инициализируется значением 1.0999999999999999, после этого переменная fFloat инициализируется тем же значением, но вследствии меньшей точности типа float в переменной оказывается значение 1.10000002, после этого инициализируется переменная iInt и значение приводится к целочисленному типу, в данном случае к 1, после этого переменная sShort становится 1 и переменная cByte тоже становится 1

	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt	=	257;
	cByte	=	iInt; // в данном случае нежелательным результатом является переполнение переменной cByte. Компилятор неявно приводит 4-рех байтовый тип к типу с одним байтом памяти, поэтому значение 257 становится 1

	unsigned char cN1=255, cN2=2, cSum;
	cSum = cN1 + cN2; // Тут тоже происходит переполнение. Компилятор приводит значение 257 к 1

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1+cN2; // Выход не происходит, поскольку изначально к знаку равно приходит значение 257 и только после этого происходит неявное приведение к нужному типу, в данном случае типа int хватает для хранения значения 257

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1=0xff, c2=2;
	unsigned char uc1=0xff, uc2=2;
	int iSum1= c1 + c2;   //(1) Изначально значение 255, которое попадает в переменную с1 типа char, переполняет её и в c1 оказывается значение -1 поэтому при сложении 2+(-1) = 1 
	int iSum2= uc1 + uc2; //(2) В этом же случае значение 255 не переполняет переменную типа unsigned char и при сложении 255+2 = 257 

	stop

	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp=100, nn=3;
	dDouble=3.3 + (nTmp / nn); // (3) При делении 100/3 в целочисленных типах мы получаем значение 33, после этого при сложении с значением 3.3 целочисленный тип неявно приводится к типу с плавающей точкой и записываеться в переменную dDouble 36.299999999999997 

	//Получите результат без потери точности с помощью оператора явного
	//приведения типа
	dDouble3 = 3.3+((double)nTmp/(double)nn);	// (4) я явно привел обе переменные и получил более точный результат 36.633333333333333

	stop


// *******************************************************
	// Задание 3. Область действия, область видимости и
	//				время существования переменных

	//   В этом фрагменте фигурируют четыре переменных с одним и тем же именем 
	// nTwin - одна глобальная, вторая определена в своем пространстве имен, 
	// (определены выше в начале модуля) третья - локальная внутри функции main(), 
	// четвертая - вложенная локальная внутри блока. 
	//   В данном задании требуется в выделенных местах фрагмента определить, к какой 
	// из четырех переменных идет обращение, а также факт существования и видимости 
	// для всех четырех, заполнив приведенные в задании таблицы 
	//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
	// Подсказка: - в окно "Watches" можно поместить как nTwin
	//			так и ::nTwin, впрочем как и TwinSpace::nTwin
	

	nTwin=100; // в этой строке мы присваиваем значение 100 глобальной переменной nTwin
	TwinSpace::nTwin = 300; // тут мы присваиваем значение 300 переменной nTwin в пространстве имён TwinSpace
	nTwin++; // прибавляем к глобальной переменной 1

	// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
	// до следующей строки еще не определена (и формально даже не существует), но место
	// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
	// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
	// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
	// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
	// Компилятор при этом все вычисляет верно.
	// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
	// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
	// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.
	int nTwin; // объявили переменную nTwin внутри функции main
	nTwin=200; // присвоили значение 200 локальной переменной nTwin
	::nTwin++; // прибавляем 1 к глобальной переменной, на это нам указывает бинарный оператор ::
	{
		int nTwin; // объявили локальную переменную внутри фигурных скобок
		nTwin=-1; // инициализировали эту переменную значением -1
		::nTwin++; // прибавили к глобальной переменной 1, значение стало 103
		TwinSpace::nTwin++; // прибавили к переменной nTwin внутри пространства имен TwinSpace, значение стало 301
	}

	nTwin--; // вычли из локальной переменной nTwin внутри функции main 1, значение стало 199


// *******************************************************
	// Задание 4. Спецификатор класса памяти - static
	// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
	// б) Напишите, когда выполняется инициализация обеих переменных?
	// в) Поясните (в комментарии) разницу между способом инициализации 
	//     переменных nStatic1 и nStatic2 и поясните побочный эффект, 
	//     влияющий на переменную nLocal2.

	for (int i=0; i<3; i++)
	{
		static int nStatic1 = 100;
		int nLocal1 = 100;
		int nLocal2 = 200;
		static int nStatic2 = nLocal2++ * 2;
		nStatic1++;
		nStatic2++;
		nLocal1++;
		stop

	}

/* 1 итерация: инициализируется статическая переменная nStatic1 значением 100. Инициализируются локальные переменные nLocal1 и nLocal2, значениями 100 и 200 соответсвенно. Иницциализируется статическая переменная nStatic2, значением 400. В конце к переменным nStatic1, nStatic2 и nLocal1 прибавляются единицы
* 2 итерация: переменная nStatic1 уже не инициализируется, она остается со значением 101. nLocal1 и nLocal2 инициализируются значениями 100 и 200. Перемеменная nStatic 2 уже не инициализируется и остается со значением 401, в связи с этим не выполняется прибавление 1 к перменной nLocal2. В конце к переменным nStatic1, nStatic2 и nLocal1 прибавляются единицы
* 3 итерация: nStatic1 не инициализируется, ее значение 102. nLocal1 = 100 и nLocal2 = 200. Static2 не иницализируется, 1 к nLocal2 не прибавляется. В самом конце итерации nStatic1 = 103, nStatic2 = 403, nLocal1 = 101, nLocal2 = 200
*/

	// Напишите:
	//   а) как изменилось поведение переменной nStatic1?
	//   б) как эта переменная ИНИЦИАЛИЗИРОВАНА ?
	for (int i=0; i<3; i++)
	{
		static int nStatic1;
		nStatic1 = 100;
		int nLocal1 = 100;
		nStatic1++;
		nLocal1++;
		stop
	}

	// Переменная nStatic1 в конце каждой итерации равна 101, потому что в каждой итерации она отдельно от объявления инициализируется значением 100 и к ней позже прибавляется 1

	
	char ucCounter = 120;
	int q = static_cast<int>(static_cast<char>(ucCounter) + static_cast<char>(5));

	for (unsigned char i = ucCounter; i < ucCounter + 10; i++) // поменял тип переменной i на unsigned char, чтобы избежать ее переполнения и вследствии бесконечного цикла
	{
		static int nStatic1;
		nStatic1 = 100;
		int nLocal1 = 100;
		nStatic1++;
		nLocal1++;
		stop
	}
	
	// Ситуация точно такая же как и в предыдущем цикле


// *******************************************************
	// Задание 5. Перечисления - enum
	// Обратите внимание на явную и неявную инициализацию констант
	// Выполняя задание по шагам, следите за значениями, которые
	// принимает переменная myColors


	enum eColors
	{
		BLACK,
		BLUE,
		GREEN,
		RED=5,
		YELLOW,
		WHITE=RED+4
	};
	
	eColors   myColors;	//объявление переменной типа eColors 
	myColors=BLACK; // значение 0
	myColors=BLUE; // значение 1
	myColors=GREEN; // значение 2
	myColors=RED; // значение 5
	myColors=YELLOW; // значение 6
	myColors=WHITE; // значение 9

	int nnn = BLACK; //любой целочисленной переменной можно присвоить
					 //значение из списка инициализирующих значений

	//Именованные константы можно использовать в выражениях:
	nnn = BLUE | YELLOW;
	nnn = BLUE + YELLOW;
	nnn = 1 | 6;

	//Раскомментируйте следующую строку и обратите
	//внимание на  ошибку при компиляции 
	myColors = eColors(1);	//модифицируйте выражение таким образом, чтобы компилятор не выдывал ошибки

	// Выполните следующее присваивание НЕ меняя перечисление и тип переменной myColors?
    myColors = eColors(123);
	stop


// *******************************************************
	// Задание 6.1 Логический тип bool
	// Выполняя задание по шагам, следите за значениями
	// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

	int nNumber = 1;
	bool b = (nNumber != 0); // b = true
	b = (nNumber == 0); // b = false
	b = (nNumber > 0); // b = true
	b = (nNumber > 1); // b = false
	b = 5; // b = true

	//Вы всегда можете преобразовать логическое значение к целому
	//явно или компилятор может это сделать самостоятельно (неявно)
	//Обратите внимание: как интерпретирует значения логических переменных компилятор?
	int tmp =  b + 1; // значение true интерпретируется 1, а false 0

	//Задание 6.2 В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным не является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.
	// Примечание: НЕ НАДО пользоваться операторами if-else, тернарным оператором и switch
	//             НАДО написать логическое выражение в одну строку.
	{
		bool isLeapYear;
		int year = 1823;
		isLeapYear = (year%400==0) || ((year%4 == 0) && (year%100!=0));
		year = 1824;
		isLeapYear = (year%400==0) || ((year%4 == 0) && (year%100!=0));
		year = 1900;
		isLeapYear = (year%400==0) || ((year%4 == 0) && (year%100!=0));
		year = 2000;
		isLeapYear = (year%400==0) || ((year%4 == 0) && (year%100!=0));

		//Вычислили значение 
		//bool isLeapYear = (year%400==0) || ((year%4 == 0) && (year%100!=0));
		// проверили значение в отладчике
		stop
	}

// *******************************************************
	// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

			//const int nN; // константу нельзя объявить без инициализации
			//nN = 1; //
	}



// ********************************************************
	//Задание 8. Логические условные операторы и операторы отношения.

	//Задание 8.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует
	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	{
		// Сформируйте значение переменной ch с помощью потока ввода
		char ch ;
		std::cin >> ch;
		if(ch >= 65 && ch<=90)
		{
			ch+=32;
			std::cout << ch;
		}
		else if(ch >= 97 && ch<=122)
		{
			ch-=32;
			std::cout << ch;
		}
		else
		{
			std::cout << "Неверное значение";
		}
		//... изменили регистр
		// здесь проверили в отладчике значение или вывели "эхо" на экран
		stop
	}


	//Задание 8.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		// в данном случае переменные должны иметь тип с плавающей точкой, поэтому нам подойдет float, double или long double.
		double x,y;

		if(x<=0)
		{
			y = 0;
		}
		else if(x>0 && x<1)
		{
			y = x;
		}
		else
		{
			y = 1;
		}
	}

	//Задание 8.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: в переменной cInput типа char дано значение символа,
	//введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
		char cInput;
		int x,y;

		std::cin >> cInput;

		switch(cInput){
			case 'y':
				y = x;
				break;
			case 'Y':
				y = x;
				break;
			case 'n':
			case 'N':
				y = x*2;
				break;
			default:
				std::cout << "Неверное значение";
				break;
		}
		//сформировали значение
		//switch
	}
	// ********************************************************
	//Задание 9. Циклы.

	//Задание 9.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Введите границы с помощью потока ввода или с помощью средств отладки.
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{
		int start,end,sum=0;

		std::cin >> start >> end;
		
		if (start > end)
		{
			std::cout << "Нижняя граница больще верхней";
		}
		else
		{
			for(int i = start; i <= end; i++){
				sum+=i;
			}
		}

		//сформироыать границы диапазона

		//проверить корректность значений
		
		// вычислить сумму
		// проверить в отладчике значение
		stop
	}


	//Задание 9.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.
	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.
	
	{
		int a;
		do{
			std::cin >> a;
		} while (a&1==0 || a<10);
	}

	//Задание 9.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
		int x = 0;
		double sum = 0;
		while(sum <= 1.7)
		{
			x++;
			sum += 1.0 / x;
		}

		std::cout << x;
	}
	return 0;
	//код завершения приложения
}	// Конец функции main()

