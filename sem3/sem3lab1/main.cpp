#include <cmath>			// математические функции
#include <locale>	// функции, устанавливающие национальные кодировки символов
#include <iostream>	// Эта - часть библиотеки STL (Standard Template Library)
#include <limits>			// Полезные константы
#include <cfloat>
#include <string>

using namespace std;		// Обеспечивает видимость имен STL
#define stop // Эта макроподстановка упрощает установку точек останова

int n;	 // Глобальная переменная. По умолчанию она обнуляется.

// 2^(1-DBL_MANT_DIG)
// Число -128 в чар это 0x11111110


void buffer_clear(){
    string trash;
    getline(cin, trash);
}

union byteswap{
    unsigned short num;
    char bytes[2];
};

namespace space	 // В пространстве имен - space
{
    int n = 1;	 // Объявлена переменная n
}				 // space определяет область видимости этой переменной

int  main(){
    setlocale(LC_ALL, "ru_RU.UTF-8");
    // Выполняя программу по шагам, следите за значениями переменных  и интерпретируйте результат, объясняя себе
    // наблюдаемые значения. Обратите внимание на разную интерпретацию отладчиком  signed и unsigned типов данных.
    char c = 'A'; // 65 'A' 0x41
    // В комментарии справа полезно проставить десятичное символьное и шестнадцатиричное
    // значения переменной после выполнения указанной строки. Вы должны видеть их в окне Autos.
    c = 0x42;		// 66 'B' 0x42 - 66 в
    c = -1;		// -1 'я' 0xff - 255 все единицы в двоичной, прибавить и будут все 0, то есть 0 значение
    c = CHAR_BIT;	 // Размер переменной типа char
    stop;

    // В комментариях напишите результат, возвращаемый оператором sizeof для
    // переменной типа wchar_t (ее размер)
    //wchar_t cw = 'Ф';
    //size_t ns = sizeof(cw); // ns = 4

    unsigned char uc = 0x41; // 65 'A'
    uc = 'B'; // 66 0x42
    uc = -1; // 255 '\xff'
    stop;

    int i = 1; // 00000000000000000000000000000001
    i = -1; // 11111111111111111111111111111111
    stop;

    unsigned int ui = 1;
    ui = -1; // в двоичном выглядит также, просто первая единица не отвечает за знак

    short s = (short)0xffff;	 // Здесь compiler генерирует warning. Измените код, чтобы убрать warning
    s = short(0xffff); // 65535
    s = 1;

    //==== Измените код, чтобы убрать warning
    unsigned short us = (short)0xffff;
    us = 5;

    long l = 0xffffffff; // 8 байт
    l = -128;

    l = FLT_MAX_EXP;	// Все эти константы вы должны найти в файле limits (float.h) и объяснить их смысл по комментариям
    //  float 128
    l = DBL_MAX_EXP;
    //  double 1024
    //  Максимальная степень двойки для чисел с плавающей точкой

    l = FLT_MANT_DIG; // 24
    //  количество цифр мантиссы
    l = DBL_DIG; // 15
    //  максимальное количество десятичных цифр в числе с плавающей точкой, которые можно надежно хранить

    l = FLT_MANT_DIG; // 24
    l = DBL_MANT_DIG; // 53

    float f = -12.5f;	 // Здесь warning. Уберите его.
    f = -1.e-27f;

    f = FLT_MAX; // 3.40282347E+38
    f = FLT_MIN; // 1.17549435E-38
    // Максимальное и минимальное число с плавающей точкой

    double d = 0.1234567890123456789123456789; // 0.12345678901234568 18 разрядов
    d = -0.123456789012345e+306; // -1.2345678901234499E+305
    d = DBL_MAX; // 1.7976931348623157E+308
    d = DBL_MIN; // 2.2250738585072014E-308
    d = DBL_EPSILON; // Самая маленькая разность между двумя пер-ми типа double
    // 2.2204460492503131E-16 числовое значение с таким отрицательным порядком, которое воспринимается машиной как ноль

    uc = ~0;		 // Побитовое отрицание 255 '\xff'
    i = ~0; // -1 (все единицы в двоичном представлении)
    stop;
    // Раннее (при компиляции) или неявное приведение типов данных
    // Объясните те значения, которые вы наблюдаете в окне Autos. Определите порядок выполения присваиваний.
    d = f = i = s = c = 1 / 3; // с = 0    s = 0   i = 0    f = 0   d = 0
    c = s = i = f = d = 100 / 3; // с = 33    s = 33   i = 33    f = 33   d = 33
    c = s = i = f = d = 10 / 3; // с = 3    s = 3   i = 3    f = 3   d = 3
    c = s = i = f = d = 1 / 3.; // // с = 0    s = 0   i = 0    f = 0.333333343   d = 0.33333333333333331
    // присваивания выполняются справа налево. В 3 примерах оба операнда целочисленные и поэтому при делении дробная часть отбрасывается. 3. - это double

    // Пример "небрежного" использования неявного приведения типов.	 Объясните результаты.
    i = 256;
    c = i; // c = 0 т.к. i = 0b100000000, при переходе компилятор отрубает лишние биты и получается  c = 0b00000000

    uc = 255;
    unsigned char u = 2, sum = uc + u; // 0b11111111 + 0b10 = 0b100000001 при приведении в чар отрубается лишний бит и получается 1
    stop;

    // Явное приведение типов	Объясните разницу результатов в строках (3) и (4)
    i = 100;
    f = d = i / 3;							// (3) f = 33
    f = d = (double)i / 3;		// (4) f = 33.3333321   d = 33.333333333333336
    f = d = double(i) / 3;			// (4) f = 33.3333321   d = 33.333333333333336
    f = d = static_cast<double>(i) / 3;		// (4) f = 33.3333321   d = 33.333333333333336
    stop;

    // Область действия, область видимости и время существования. В этом фрагменте фигурируют четыре
    //  переменных с одним и тем же именем n.  Одна - глобальная, вторая определена в своем пространстве имен,
    // третья - локальная внутри функции main(), четвертая - локальная внутри блока.
    //  Обратите внимание, что глобальная переменная и та, что в пространстве имен space - объявлены вне функции main()
    // Определите, к какой из четырех переменных идет обращение, cформулируйте область действия и область видимости
    // каждой переменной. Для выполнения задания рекомендуется пользоваться  закладкой "Watches" или "Locals" окна
    // "Autos". Подсказка: В окно "Watches" можно поместить сразу все переменные (n, ::n, и space::n)
    n = 100; // глобальная
    space::n = 200; // внутри space
    n++; // глобальная
    int n;		//Где живет эта переменная ? Внутри main
    n = 10; // main
    ::n++; // глобальная

    {				//  Начало блока
        int n;		// Эта переменная живет внутри блока
        n = -1; // внутри блока
        n++; // внутри блока
        ::n++; // глобальная
        space::n++; // внутри space
    }		// Конец блока
    n--; // main
    ::n--; // глобальная
    space::n--; // main

    // Спецификатор класса памяти - static Выполняя задание по шагам, обратите внимание на  разное поведение
    // переменных nLoc и nStat
    {
        Again:
        int outer;
        for (int i = 0; i < 5; i++)
        {
            static int nStat;
            {
                int nLoc = 0;
                nLoc++;		nStat++;
            }
            outer = nStat;
        }
        if (outer < 10)
            goto Again;
    }
    // Перечисления - enum. Обратите внимание на явную и неявную инициализацию констант
    enum RANK
    {
        One, // 0
        Two, // 1
        Three, // 2
        Four, // 3
        Jack = 6, // 6
        Queen, // 7
        Ace = Queen + 3, // 10
        Joker = 20// 20
    };
    typedef RANK RANG;

    RANG r = Jack;
    if (r == Jack)
        r = Queen;

    if (r == Queen)
    {
        // Любой целочисленной переменной можно присвоить enum-переменную
        int i = r;
        r = RANK(i++);		// Обратное преобразование надо указывать явно
        i = r;
        r = RANK(++i); // r = 8
        i = r;
    }
    RANK rr = Ace;
    stop;
    //	Логический тип bool.	Выполняя задание по шагам, следите за значениями переменной b
    {
        int n = 127;
        bool b = n != 0; // 1
        b = n == 0; // 0
        b = n > 0; // 1
        b = n <= 0; // 0
        b = n > 1; // 1

        int num = static_cast<int>(b); // 1
        if (b)
            cout << "\n\t My flag is: true" << "   or: " << b
                 << "\n\t Conversion to int: " << num << endl;
        b = n == num;
        cout << "\n\t Now the flag is: false" << "   or: " << b;
    }

    //	Модификатор const
    const double pi = acos(-1.);
    double space_permiability = 4.e-7 * pi;		//	Магнитная проницаемость пустоты
    const int dozen = 12;
    int var = dozen;

    //	Раскомментируйте следующую строчку и объясните ошибку компиляции (l-value означает left value)
    //	dozen = 1; объекты с модификатором не могут быть изменены после объявления с инициализацией
    //	Директивы условной трансляции. Объясните значение, которое принимает переменная version.
    //	Что нужно сделать для того, чтобы результат был другим?
     //Удалить создание макроса с названием MSVER400 и создать с названием MSVER400 или не создавать

#define MSVER400
    const char* version;
#if defined MSVER400
    version = "version 4.00";
#elif defined MSVER311
    version = "version 3.11";
#else
	version = "version Unknown";
#endif

    cout << endl << version;
    stop;

    //В окне ClassView или Solution Explorer поставьте фокус на имя проекта дайте команду Project/Properties.
    //	В диалоге Property Pages щелкните на папке Configuration Properties, убедитесь, что в разделе Code Generation
    //	установлена константа компиляции _DEBUG. Создайте директивы препроцессора и код С++, которые
    //	в зависимости от действующей конфигурации проекта (_DEBUG или NDEBUG) выводят соответствующее
    //	сообщение. Измените конфигурацию проекта (в диалоге Property Pages) и проверьте ваш код.
    //	Чтобы изменить конфигурацию пользуйтесь кнопкой Configuration Manager

#if defined DEBUG
    cout << endl << "Debug" << endl;
#else
    cout << endl << "Release" << endl;
#endif


    //	Простейшие циклы. Объясните суть происходящего.
    {
        // Цикл while надо использовать, когда неизвестно количество итераций (повторений) цикла.
        cout << "\n\nGradually eat out all the units:\n\n";
        unsigned short us = 0xff;
        while (us)
        {
            cout << hex << us << endl;
            us &= us - 1;
        }
        cout << hex << us << "\nDone\n";
        // Цикл for надо использовать, когда известно количество итераций и/или есть код подготовки.
        // Подсказка: odd - нечетое, even - четное.
        cout << "\n\nShow even-odd:\n\n";
        for (int i = 0; i < 10; i++)
        {
            if (i & 1)
                cout << i << " - odd\n";
            else
                cout << i << " - even\n";
        }
        // Когда нужно использовать цикл do-while?
        char c = ' ';
        do
        {
            if (c == 'a')
                cout << "\nAction is a delegate type in C#";
            else if (c == 'b')
                cout << "\nbreak is one of the 'leave' statements in all C-like languages";
            else if (c == 'c')
                cout << "\ncontinue is a 'go on' statement in all C-like languages";
            else if (c == 'd')
                cout << "\ndo-while is a rarely used loop statement in all C-like languages";
            else
                cout << "\nPlease read the rules of this loop";
            cout << "\n\nEnter chars: a, b, c, d (q - to quit):\n\n";
            cin >> c;
            if (c == 'q')
                cout << "\nI am going to leave the loop\n";
        } while (c != 'q');
        stop;
    }
    //	Логические условные операторы и циклы. Функция y = f(x) задана графиком
    //	Напишите фрагмент кода, который с шагом 0.1 вычисляет y = f(x)  и выводит в консольное окно значения x и y.
    //	  y
    //	  |
    //	 2|__________
    //	  |         /\
	//	  |        /  \
	//	  |       /    \
	//	  |______/      \__________  x
    //	  0      1   2   3
    //	 Реалируйте 2 варианта этого алгоритма:   1. Используйте операторы if	 2. Используйте тернарные операции    ? :

    // Оператор if:

    double k = 0;

    for (int j = 0; j<=35; j+=1){
        k = (double)j/10;
        if(k>1 && k<=2){
            cout << 2*k-2 << endl;
        } else if(k>2 && k<3){
            cout << -2*k+6 << endl;
        } else{
            cout << 0. << endl;
        }
    }

    cout << "\n\n";

    // Тернарнарные операции

    for (int j = 0; j<=35; j+=1){
        k = (double)j/10;
        cout << ( (k<=1 || k>=3) ? ( 0. ) : ( (k<2) ?  ( 2*k-2) : (-2*k+6) ) ) << endl;
    }

    cout << "\n\n";

    //	Напишите фрагмент, который с помощью for и switch реализует следующую логику. Если пользователь ввел:
    //	символ 'a',   ваш алгоритм выводит  "Ok" (в кавычках)
    //	символ 'b',   ваш алгоритм выводит  Bell (alert - звуковой сигнал)
    //	символ 'с',   ваш алгоритм выводит  число, которое равно количеству введенных символов
    //	символ 'Esc', ваш алгоритм выводит  "to quit use 'q'"
    //	символ 'q',   ваш алгоритм выводит  "Bye" и выходит из цикла ввода

    int counter = 0;

    cout << "Enter value: ";
    for(char p = 0; p != 'q'; cin >> p){
        ++counter;
        switch (p) {
            case 'a':
                cout << "\"Ok\"" << endl;
                break;
            case 'b':
                cout << '\a' << endl;
                break;
            case 'c':
                cout << "Number of entries: " << counter << endl;
                break;
            case 27: // 27 ASCII
                cout << "to quit use \'q\'" << endl;
                continue;
            default:
                cout << endl;
                continue;

        }
        buffer_clear();
        fflush(stdin);

        cout << "Enter value: ";
    }

    //	Побитовые операции:  |, &, ~, ^ и сдвиги >>, <<
    //	Поменяйте местами байты переменной flags и выведите результат в консолное окно unsigned short flags = 0xaabb;
    //	Ваш код
    unsigned short flags = 0xaabb;

    unsigned short swapped = ((flags & 0x00FF) << 8) | ((flags & 0xFF00) >> 8);

    cout <<"\n bits = " << hex << swapped;

//    byteswap swap = {};
//    swap.num = flags;
//
//    char temp = swap.bytes[0];
//    swap.bytes[0] = swap.bytes[1];
//    swap.bytes[1] = swap.bytes[0];


    //	Для вывода в шестнадцатеричном виде используйте  cout <<"\n bits = " << hex << flags;
    //	В переменной unsigned char byte = 0x26;
    //      - установите в единицу 3-й бит (счет от нуля). Выведите результат.
    //	- инвертируйте два младших бита. Выведите результат.
    //      - обнулите 4 младших бита. Выведите результат.

    char byte = 0x26;
    byte = byte|0b1000;
    cout <<endl << hex << (int)byte << endl<<dec<< (int)byte;

    byte = byte^0b00000011;
    cout <<endl << hex << (int)byte << endl<<dec<< (int)byte;

    byte = byte&0xF0;
    cout <<endl << hex << (int)byte << endl<<dec<< (int)byte;

    //	cout <<endl << hex << flags << endl<<dec<<flags;
    cout << "\n\n";
}	// Конец функции main()
